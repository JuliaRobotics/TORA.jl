var documenterSearchIndex = {"docs":
[{"location":"solver_interfaces/#Solver-Interfaces","page":"Solver Interfaces","title":"Solver Interfaces","text":"","category":"section"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"Problems created with TORA.jl are first converted into an NLP problem, and then solved using Ipopt or Knitro. The two methods available for this are:","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"Pages = [\"solver_interfaces.md\"]","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"These methods have different names but a very similar signature, purpose, and functionality.","category":"page"},{"location":"solver_interfaces/#Arguments","page":"Solver Interfaces","title":"Arguments","text":"","category":"section"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"The main arguments of the solve_with_* methods are a Problem and a Robot. Moreover, there are optional keyword arguments that can be passed to these methods in order to customize the NLP problem transcribed from the high-level description Problem. These optional arguments are listed and explained below.","category":"page"},{"location":"solver_interfaces/#Initial-Guess","page":"Solver Interfaces","title":"Initial Guess","text":"","category":"section"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"initial_guess=Float64[]","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"This is the starting point for the solver. In other words, this is the value estimation of each decision variable. Providing a good initial guess is very important for the solver to converge quickly and in as few iterations as possible. An example of passing an initial guess is shown in Tutorial > Providing an Initial Guess.","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"The default value for the initial_guess is an empty array, i.e., Float64[]. During transcription, TORA.jl checks the value of initial_guess. If an array has been provided, it is passed to the solver; if a guess has not been provided, an array filled with zeros is passed to the solver instead.","category":"page"},{"location":"solver_interfaces/#Dynamics-Defects","page":"Solver Interfaces","title":"Dynamics Defects","text":"","category":"section"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"use_inv_dyn=false","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"TORA.jl transcribes a Problem into an NLP problem using an approach called Direct Transcription.[1] This approach discretizes the continuous optimization problem in time, and requires nonlinear equality constraints to enforce the full dynamics of the system—known as dynamics defects. There are two options available to define these constraints: using forward dynamics or inverse dynamics. For more details, please read How TORA.jl Works.","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"The default value for use_inv_dyn is false. I.e., the default behaviour is to use forward dynamics. In order to use inverse dynamics for defining the dynamics defects, use_inv_dyn should be set to true.","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"[1]: Betts, John T. Practical Methods for Optimal Control and Estimation Using Nonlinear Programming. SIAM, 2010.","category":"page"},{"location":"solver_interfaces/#Energy-Minimization","page":"Solver Interfaces","title":"Energy Minimization","text":"","category":"section"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"minimise_τ=false","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"By default, problems formulated with TORA.jl are feasibility problems. In other words, the goal for the solver is to find a set of values that satisfies all the constraints of a Problem. However, it is possible to define a cost function to be minimized. (Or a value function to be maximized.)","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"The default value for minimise_τ is false. I.e., the default behaviour is to solve the feasibility problem, without optimizing any objective function. Alternatively, if minimise_τ is set to true, TORA.jl will minimize the joint torques required by the trajectory being computed.","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"warning: Warning\nOptimizing an objective function is very costly, and may take a significant amount of iterations depending on the Initial Guess provided to the solver.","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"note: Note\nCurrently, TORA.jl provides only one cost function: minimization of torques. Different cost functions can be used, but they need to be specified by the user manually. Feel free to open a New Issue on GitHub if you need some pointers on how and where to get started.","category":"page"},{"location":"solver_interfaces/#Solver-User-Options","page":"Solver Interfaces","title":"Solver User Options","text":"","category":"section"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"user_options=Dict()","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"This parameter allows to pass custom options to the actual NLP solvers, i.e., to Ipopt and to Knitro. The options that can be set depend on each solver. The list of available options for Ipopt is given here, and for Knitro here.","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"The default value for user_options is an empty dictionary. A dictionary of key-value pairs can be passed to the solver instead.","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"As an example, suppose we want to use the linear solver MA57. Then, for Ipopt we would set","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"user_options=Dict(\"linear_solver\" => \"ma57\")  # for Ipopt","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"and for Knitro","category":"page"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"user_options=Dict(KNITRO.KN_PARAM_LINSOLVER => KNITRO.KN_LINSOLVER_MA57)   # for Knitro","category":"page"},{"location":"solver_interfaces/#Methods","page":"Solver Interfaces","title":"Methods","text":"","category":"section"},{"location":"solver_interfaces/","page":"Solver Interfaces","title":"Solver Interfaces","text":"solve_with_ipopt\nsolve_with_knitro","category":"page"},{"location":"solver_interfaces/#TORA.solve_with_ipopt","page":"Solver Interfaces","title":"TORA.solve_with_ipopt","text":"solve_with_ipopt(problem, robot;\n                 initial_guess=Float64[],\n                 use_inv_dyn=false,\n                 minimise_τ=false,\n                 user_options=Dict())\n\nSolve the nonlinear optimization problem with Ipopt.\n\nFurther options can be set using the keyword arguments. See Solver Interfaces.\n\nKeyword arguments\n\ninitial_guess::Vector{Float64}=Float64[]: the starting point for the solver.\nuse_inv_dyn::Bool=false: if true, enables the use of inverse dynamics instead of forward dynamics.\nminimise_τ::Bool=false: if true, activates a cost function to minimize the joint torques.\nuser_options::Dict=Dict(): the user options for Ipopt.\n\nSee also: solve_with_knitro\n\n\n\n\n\n","category":"function"},{"location":"solver_interfaces/#TORA.solve_with_knitro","page":"Solver Interfaces","title":"TORA.solve_with_knitro","text":"solve_with_knitro(problem, robot;\n                  initial_guess=Float64[],\n                  use_inv_dyn=false,\n                  minimise_τ=false,\n                  user_options=Dict())\n\nSolve the nonlinear optimization problem with Knitro.\n\nFurther options can be set using the keyword arguments. See Solver Interfaces.\n\nKeyword arguments\n\ninitial_guess::Vector{Float64}=Float64[]: the starting point for the solver.\nuse_inv_dyn::Bool=false: if true, enables the use of inverse dynamics instead of forward dynamics.\nminimise_τ::Bool=false: if true, activates a cost function to minimize the joint torques.\nuser_options::Dict=Dict(): the user options for Knitro.\n\nSee also: solve_with_ipopt\n\n\n\n\n\n","category":"function"},{"location":"robot/#Robot","page":"Robot","title":"Robot","text":"","category":"section"},{"location":"robot/","page":"Robot","title":"Robot","text":"Modules = [TORA]\nOrder = [:type]\nPages = [\"robot.jl\"]","category":"page"},{"location":"robot/#TORA.Robot","page":"Robot","title":"TORA.Robot","text":"A Robot represents a mechanism, its state, and other relevant objects.\n\nRelevant fields in Robot\n\nThe arrays q_lo, q_hi, v_lo, v_hi, τ_lo, τ_hi store the lower and upper bounds of the joint positions, velocities, and torques, respectively.\nThe number of generalized coordinates, generalized velocities, and actuated joints are stored in n_q, n_v, n_τ, respectively.\nThe end-effector frame is stored in frame_ee.\n\n\n\n\n\n","category":"type"},{"location":"robot/#TORA.Robot-Tuple{String, RigidBodyDynamics.Mechanism, RigidBodyDynamics.Spatial.CartesianFrame3D, MeshCatMechanisms.MechanismVisualizer}","page":"Robot","title":"TORA.Robot","text":"Robot(urdfpath, mechanism, frame_ee, mvis)\n\nCreate a new Robot.\n\n\n\n\n\n","category":"method"},{"location":"robot/#Index","page":"Robot","title":"Index","text":"","category":"section"},{"location":"robot/","page":"Robot","title":"Robot","text":"Pages = [\"robot.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"robot/#Methods","page":"Robot","title":"Methods","text":"","category":"section"},{"location":"robot/","page":"Robot","title":"Robot","text":"Modules = [TORA]\nOrder = [:function]\nPages = [\"robot.jl\"]","category":"page"},{"location":"robot/#TORA.create_robot_franka-Tuple{String, MeshCat.Visualizer}","page":"Robot","title":"TORA.create_robot_franka","text":"create_robot_franka(model, vis)\n\nCreate a new Franka Emika robot.\n\n\n\n\n\n","category":"method"},{"location":"robot/#TORA.create_robot_kinova_gen2-Tuple{String, MeshCat.Visualizer}","page":"Robot","title":"TORA.create_robot_kinova_gen2","text":"create_robot_kinova_gen2(model, vis)\n\nCreate a new Kinova Gen2 robot.\n\n\n\n\n\n","category":"method"},{"location":"robot/#TORA.create_robot_kinova_gen3-Tuple{String, MeshCat.Visualizer}","page":"Robot","title":"TORA.create_robot_kinova_gen3","text":"create_robot_kinova_gen3(model, vis)\n\nCreate a new Kinova Gen3 lite robot.\n\n\n\n\n\n","category":"method"},{"location":"robot/#TORA.create_robot_kuka-Tuple{String, MeshCat.Visualizer}","page":"Robot","title":"TORA.create_robot_kuka","text":"create_robot_kuka(model, vis)\n\nCreate a new KUKA LBR iiwa 7/14 robot.\n\n\n\n\n\n","category":"method"},{"location":"robot/#TORA.create_robot_ur-Tuple{String, MeshCat.Visualizer}","page":"Robot","title":"TORA.create_robot_ur","text":"create_robot_ur(ur_type, vis)\n\nCreate a new Universal Robots robot.\n\n\n\n\n\n","category":"method"},{"location":"new_robot/#Adding-a-New-Robot","page":"Adding a New Robot","title":"Adding a New Robot","text":"","category":"section"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"This tutorial explains how to use TORA.jl with a robot that has not yet been added to the package.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"As an example, I will demonstrate how to add the Kinova Gen3 lite robot.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"tip: Tip\nIf you are adding a widely available robot, consider creating a fork of TORA.jl and following this guide such that you can submit a Pull Request once you are done.","category":"page"},{"location":"new_robot/#Add-the-Robot-Submodule","page":"Adding a New Robot","title":"Add the Robot Submodule","text":"","category":"section"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"Usually, widely-used robots have existing GitHub repositories associated with them. For the Kinova Gen3 lite, that repository is Kinovarobotics/ros_kortex.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"To add the repository as a submodule, I will run","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"git submodule add https://github.com/Kinovarobotics/ros_kortex","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"inside the root of the TORA.jl package.","category":"page"},{"location":"new_robot/#Prepare-the-Robot-URDF","page":"Adding a New Robot","title":"Prepare the Robot URDF","text":"","category":"section"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"The next step is to prepare the URDF model of the robot, which we will load later using RigidBodyDynamics.jl.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"After a bit of searching, I found the .xacro file of the robot I want under TORA.jl/ros_kortex/kortex_description/robots/gen3_lite_gen3_lite_2f.xacro.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"Inside a catkin workspace, I will convert the .xacro file into a .urdf by running","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"rosrun xacro xacro -o gen3_lite_gen3_lite_2f.urdf gen3_lite_gen3_lite_2f.xacro","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"Afterwards, I'll just move the generated .urdf file to the TORA.jl/robots folder.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"Now I need to open the .urdf with a text editor, and look for the end-effector frame. Scrolling down, I see:","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"<!-- Tool frame used by the arm -->\n<link name=\"tool_frame\"/>","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"I will note down the name of this frame, as I will need it soon.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"note: Note\nThe default .urdf of other robots may not come with a tool frame. In such cases, you can add one manually. Look at other existing .urdf files for examples in TORA.jl/robots.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"As I scroll through the .urdf, I notice that this robot has two actuated fingers:","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"(...)\n<joint name=\"right_finger_bottom_joint\" type=\"revolute\">\n(...)\n<joint name=\"right_finger_tip_joint\" type=\"revolute\">\n(...)\n<joint name=\"left_finger_bottom_joint\" type=\"revolute\">\n(...)\n<joint name=\"left_finger_tip_joint\" type=\"revolute\">\n(...)","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"I am not very interested in planning a trajectory for each of these joints with TORA.jl, so I will manually edit the .urdf and change the type of these joints from \"revolute\" to \"fixed\".","category":"page"},{"location":"new_robot/#Write-the-Create-Method","page":"Adding a New Robot","title":"Write the Create Method","text":"","category":"section"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"The last thing I need to do is write a method wrapping the Robot constructor in src/robot.jl.","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"function create_robot_kinova_gen3_lite(vis::Visualizer)\n    package_path = joinpath(@__DIR__, \"..\", \"ros_kortex\")\n    urdfpath = joinpath(@__DIR__, \"..\", \"robots\", \"gen3_lite_gen3_lite_2f.urdf\")\n\n    mechanism = parse_urdf(urdfpath, remove_fixed_tree_joints=false)\n    frame_ee = default_frame(findbody(mechanism, \"tool_frame\"))\n    remove_fixed_tree_joints!(mechanism)\n\n    urdfvisuals = URDFVisuals(urdfpath, package_path=[package_path])\n    mvis = MechanismVisualizer(mechanism, urdfvisuals, vis[\"robot\"])\n    # setelement!(mvis, frame_ee)  # Visualize a triad at the end-effector\n\n    Robot(urdfpath, mechanism, frame_ee, mvis)\nend","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"As a convention, the name of this method should start with create_robot_ followed by the name of the robot. The string package_path should point to the submodule of the robot, which contains the meshes needed to render the robot in the visualizer. The urdfpath string should point to the .urdf file of the robot. Finally, frame_ee should be assigned to the tool frame of the robot, which in this case is \"tool_frame\"—the name I had noted down before.","category":"page"},{"location":"new_robot/#Test-the-New-Robot","page":"Adding a New Robot","title":"Test the New Robot","text":"","category":"section"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"The robot is now ready to be used with TORA.jl. To test it out, I will try to run the Tutorial notebook with the new robot. Instead of calling","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"robot = TORA.create_robot_kuka_iiwa_14(vis)","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"I will call","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"robot = TORA.create_robot_kinova_gen3_lite(vis)","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"Running the rest of the tutorial notebook, I get:","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"<video src=\"../assets/videos/kinova_gen3_lite.mp4\" autoplay loop muted width=\"100%\" style=\"margin-bottom: 1em;\">Your browser does not support the video tag.</video>","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"note: Note\nThe Kinova Gen3 lite is smaller than the KUKA LBR iiwa 14 used in the Tutorial. Therefore, the circle that the robot is tracing in the video above is lower, and the position of the end-effector in task-space is given bypos = [0.5, 0.2 * cos(θ), 0.5 + 0.2 * sin(θ)]","category":"page"},{"location":"new_robot/","page":"Adding a New Robot","title":"Adding a New Robot","text":"note: Note\nTo make the video above loop seamlessly, I also fixed the initial and final joint positions to the same configuration, using the fix_joint_positions! method.","category":"page"},{"location":"solver_log/#Solver-Log","page":"Solver Log","title":"Solver Log","text":"","category":"section"},{"location":"solver_log/","page":"Solver Log","title":"Solver Log","text":"Modules = [TORA]\nOrder = [:type]\nPages = [\"solverlog.jl\"]","category":"page"},{"location":"solver_log/#TORA.SolverLog","page":"Solver Log","title":"TORA.SolverLog","text":"During optimization, a SolverLog is used to store convergence information.\n\nA SolverLog can log the following:\n\nx::Matrix{Float64}: the history of the decision variables for every iteration.\nabs_feas_error::Vector{Float64}: the absolute feasibility error evolution.\nabs_opt_error::Vector{Float64}: the absolute optimality error evolution.\nobj_value::Vector{Float64}: the evolution of the objective function value.\nfc_evals::Vector{Float64}: the evolution of the number of function evaluations.\nga_evals::Vector{Float64}: the evolution of the number of gradient evaluations.\nnStatus::Int: the solution status return code.\n\nThe actual values stored in a SolverLog depend on the implementation of the callback used by each solver for every new point. Using Ipopt, the callback is set with Ipopt.setIntermediateCallback. Using Knitro, the callback is set with KNITRO.KN_set_newpt_callback.\n\n\n\n\n\n","category":"type"},{"location":"solver_log/#TORA.SolverLog-Tuple{Int64}","page":"Solver Log","title":"TORA.SolverLog","text":"SolverLog(N)\n\nCreate an empty NLP solver log.\n\nArguments\n\nN::Int: the total number of decision variables of the NLP.\n\nSee also: update!\n\n\n\n\n\n","category":"method"},{"location":"solver_log/#Index","page":"Solver Log","title":"Index","text":"","category":"section"},{"location":"solver_log/","page":"Solver Log","title":"Solver Log","text":"Pages = [\"solver_log.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"solver_log/#Methods","page":"Solver Log","title":"Methods","text":"","category":"section"},{"location":"solver_log/","page":"Solver Log","title":"Solver Log","text":"Modules = [TORA]\nOrder = [:function]\nPages = [\"solverlog.jl\"]","category":"page"},{"location":"solver_log/#Base.length-Tuple{SolverLog}","page":"Solver Log","title":"Base.length","text":"length(log) -> Integer\n\nReturn the length of a SolverLog.\n\nThe length of a SolverLog is the same as the number of iterations taken to solve the problem.\n\n\n\n\n\n","category":"method"},{"location":"solver_log/#TORA.load!-Tuple{SolverLog, String}","page":"Solver Log","title":"TORA.load!","text":"load!(log, file)\n\nLoad an .npz file and store it in a SolverLog object.\n\nSee also: save\n\n\n\n\n\n","category":"method"},{"location":"solver_log/#TORA.save-Tuple{SolverLog, String}","page":"Solver Log","title":"TORA.save","text":"save(log, file)\n\nSave a SolverLog to an .npz file.\n\nSee also: load!\n\n\n\n\n\n","category":"method"},{"location":"solver_log/#TORA.update!-Tuple{SolverLog}","page":"Solver Log","title":"TORA.update!","text":"update!(log; <keyword arguments>)\n\nUpdate a SolverLog object.\n\nKeyword arguments\n\nx=zeros(size(log.x, 1)): an intermediate iterate point.\nabs_feas_error=0: the absolute feasibility error at the current point.\nabs_opt_error=0: the absolute optimality error at the current point.\nobj_value=0: the value of the objective function at the current point.\nfc_evals=0: the number of function evaluations requested by the NLP solver so far.\nga_evals=0: the number of gradient evaluations requested by the NLP solver so far.\n\n\n\n\n\n","category":"method"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"First things first: install Julia. You can follow my tutorial here.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To install TORA.jl, start Julia and enter Pkg mode by pressing ], and then run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"add https://github.com/JuliaRobotics/TORA.jl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"After the command above, you are pretty much done.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: You are good to go\nI recommend you to go and follow the tutorial now.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The installation notes below need not be followed right now. At the end of the tutorial, I will refer you back here.","category":"page"},{"location":"install/#HSL-Routines-for-Ipopt","page":"Installation","title":"HSL Routines for Ipopt","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"This section will guide you through the steps required to install the Harwell Subroutine Library (HSL).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"info: Information about Ipopt and the HSL\nTORA.jl uses Ipopt (Interior-Point OPTimizer) by default, a large-scale nonlinear optimization solver.Ipopt itself depends on other solvers to handle systems of linear equations.The Harwell Subroutine Library (HSL) provides a number of linear solvers that can be used in Ipopt. ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Choose a good linear solver\nPicking a good linear solver is extremely important to maximise the performance of nonlinear solvers.For example, the linear solver MA27 is out dated and can be quite slow. MA57 is a much better alternative, especially for highly-sparse problems (such as trajectory optimization problems).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"First, install the following dependencies:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"sudo apt install gcc g++ gfortran git patch wget pkg-config liblapack-dev libmetis-dev","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Clone Ipopt to your Home folder:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone https://github.com/coin-or/Ipopt.git ~/Ipopt","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Clone the COIN-OR Tools project ThirdParty-HSL into Ipopt's folder:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cd ~/Ipopt\ngit clone https://github.com/coin-or-tools/ThirdParty-HSL.git","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Go to http://www.hsl.rl.ac.uk/ipopt/ and download Coin-HSL Full (Stable) [Linux x86_64].","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"warning: Warning\nDownloading Coin-HSL Full requires a licence. If you are an academic, you can get one for free.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Extract and rename the downloaded archive into ~/Ipopt/ThirdParty-HSL:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cd ~/Ipopt/ThirdParty-HSL\ntar -xvzf ~/Downloads/coinhsl-2019.05.21.tar.gz\nmv coinhsl-2019.05.21 coinhsl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Configure, make, and install HSL:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"./configure\nmake\nsudo make install","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"For compatibility, create libhsl.so linking to libcoinhsl.so:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cd /usr/local/lib\nsudo ln -s libcoinhsl.so libhsl.so","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Finally, add the following line to the end of your .bashrc (or .zshrc):","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"export LD_LIBRARY_PATH=\"/usr/local/lib:$LD_LIBRARY_PATH\"","category":"page"},{"location":"install/#Artelys-Knitro","page":"Installation","title":"Artelys Knitro","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"unknown: Not ready yet\nDocumentation to be written.","category":"page"},{"location":"problem/#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"problem/","page":"Problem","title":"Problem","text":"Modules = [TORA]\nOrder = [:type]\nPages = [\"problem.jl\"]","category":"page"},{"location":"problem/#TORA.Problem","page":"Problem","title":"TORA.Problem","text":"A Problem stores the high-level description of a motion planning problem.\n\nThis is the main structure of the package. The idea is for users to start with an empty problem for a given robot. Then, in order to specify the requirements for the motion they want to compute, they can add different types of constraints, one by one. See Creating a Problem and Defining Constraints for detailed examples.\n\nEventually, the problem becomes a complex description with all the requirements. Once the description is finalized, it can be optimized. This happens in one of the TORA.solve_with_* functions, which does the heavy-lifting of converting a Problem (the high-level description) into an NLP problem that can be solved using off-the-shelf solvers, such as Ipopt and Knitro.\n\nSee also: solve_with_ipopt, solve_with_knitro\n\n\n\n\n\n","category":"type"},{"location":"problem/#TORA.Problem-Tuple{Robot, Int64, Float64}","page":"Problem","title":"TORA.Problem","text":"Problem(robot, num_knots, dt)\n\nCreate an empty Problem.\n\nArguments\n\nrobot::Robot: the robot associated with this Problem.\nnum_knots::Int: the number of knots used to represent the motion.\ndt::Float64: the time step duration between each two consecutive knots.\n\nSee also: show_problem_info\n\n\n\n\n\n","category":"method"},{"location":"problem/#Index","page":"Problem","title":"Index","text":"","category":"section"},{"location":"problem/","page":"Problem","title":"Problem","text":"Pages = [\"problem.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"problem/#Methods","page":"Problem","title":"Methods","text":"","category":"section"},{"location":"problem/","page":"Problem","title":"Problem","text":"Modules = [TORA]\nOrder = [:function]\nPages = [\"problem.jl\"]","category":"page"},{"location":"problem/#TORA.constrain_ee_position!-Tuple{Problem, Any, Any}","page":"Problem","title":"TORA.constrain_ee_position!","text":"constrain_ee_position!(problem, knot, position)\n\nFix the end-efector positions of the robot at a specific knot.\n\nSee also: fix_joint_positions!, fix_joint_velocities!, fix_joint_torques!\n\n\n\n\n\n","category":"method"},{"location":"problem/#TORA.export_trajectory-Tuple{String, Problem, Robot, Any}","page":"Problem","title":"TORA.export_trajectory","text":"export_trajectory(file, problem, robot, x)\n\nExport a trajectory to a .npz file.\n\n\n\n\n\n","category":"method"},{"location":"problem/#TORA.fix_joint_positions!-Tuple{Problem, Robot, Any, Any}","page":"Problem","title":"TORA.fix_joint_positions!","text":"fix_joint_positions!(problem, robot, knot, q)\n\nFix the joint positions of the robot at a specific knot.\n\nSee also: fix_joint_velocities!, fix_joint_torques!\n\n\n\n\n\n","category":"method"},{"location":"problem/#TORA.fix_joint_torques!-Tuple{Problem, Robot, Any, Any}","page":"Problem","title":"TORA.fix_joint_torques!","text":"fix_joint_torques!(problem, robot, knot, τ)\n\nFix the joint torques of the robot at a specific knot.\n\nSee also: fix_joint_positions!, fix_joint_velocities!\n\n\n\n\n\n","category":"method"},{"location":"problem/#TORA.fix_joint_velocities!-Tuple{Problem, Robot, Any, Any}","page":"Problem","title":"TORA.fix_joint_velocities!","text":"fix_joint_velocities!(problem, robot, knot, v)\n\nFix the joint velocities of the robot at a specific knot.\n\nSee also: fix_joint_positions!, fix_joint_torques!\n\n\n\n\n\n","category":"method"},{"location":"problem/#TORA.show_problem_info-Tuple{Problem}","page":"Problem","title":"TORA.show_problem_info","text":"show_problem_info(problem)\n\nOutput a summary of the problem, including the number of knots with constraints.\n\n\n\n\n\n","category":"method"},{"location":"#TORA.jl","page":"Home","title":"TORA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TORA stands for Trajectory Optimization for Robot Arms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started, see the Tutorial.","category":"page"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package allows users to define tasks for robot manipulators with simple high-level descriptions. Then, TORA.jl does the heavy-lifting! It converts those descriptions into numerical optimization problems, which are in turn tackled by state-of-the-art solvers. The final result of the optimization is a full trajectory (joint positions, joint velocities, and joint torques) taking into account the whole-body dynamics of the system. These trajectories can be commanded to your favourite robot, either in simulation or in real life.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<figure>\n    <img src=\"./assets/diagram.svg\" alt=\"diagram\" width=\"100%\">\n    <figcaption><strong>Diagram 1.</strong> Intended use of this package.</figcaption>\n</figure>","category":"page"},{"location":"#Functionality","page":"Home","title":"Functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, the highlights of TORA.jl are as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple interface to define constrained motion-planning problems\nFormulation of the optimal control problem using Direct Transcription\nOptimization of NLP problems using state-of-the-art solvers (Ipopt.jl and KNITRO.jl)\nFull system dynamics enforced with either forward or inverse dynamics (RigidBodyDynamics.jl)\nAutomatic differentiation of sparse Jacobians (ForwardDiff.jl and SparseDiffTools.jl)\nAutomatic sparsity detection of Jacobians (SparsityDetection.jl)\nVisualization of robot models and motion plans (MeshCat.jl)","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Overall, the direct transcription technique implemented in TORA.jl stems from:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Betts, John T. Practical Methods for Optimal Control and Estimation Using Nonlinear Programming. SIAM, 2010.","category":"page"},{"location":"#Citing-this-library","page":"Home","title":"Citing this library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@misc{torajl,\n  author = {Henrique Ferrolho and contributors},\n  title  = {\\href{https://github.com/JuliaRobotics/TORA.jl}{TORA.jl}},\n  url    = {https://github.com/JuliaRobotics/TORA.jl},\n  year   = 2020\n}","category":"page"},{"location":"how_it_works/#How-TORA.jl-Works","page":"How TORA.jl Works","title":"How TORA.jl Works","text":"","category":"section"},{"location":"how_it_works/","page":"How TORA.jl Works","title":"How TORA.jl Works","text":"unknown: Not ready yet\nDocumentation to be written.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial assumes you have already installed Julia and TORA.jl. See Installation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nA Jupyter notebook of this tutorial is available here.","category":"page"},{"location":"tutorial/#Setup","page":"Tutorial","title":"Setup","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We are going to use TORA.jl as well as other packages to visualize and handle rigid-body mechanisms.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TORA\nusing MeshCat\nusing RigidBodyDynamics","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TORA\nusing MeshCat\nusing RigidBodyDynamics\n\nvis = Visualizer()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Try to call TORA.greet(). It should simply print \"Hello World!\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.greet()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we want to create a 3D viewer using MeshCat.jl","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"vis = Visualizer()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's open the visualizer (in a separate browser tab)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"open(vis)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It should look like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Empty viewer)","category":"page"},{"location":"tutorial/#Loading-a-Robot","page":"Tutorial","title":"Loading a Robot","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After starting the viewer, we are now ready to load a robot. Let's load a KUKA LBR iiwa 14 with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"robot = TORA.create_robot_kuka_iiwa_14(vis)\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nTo load a different robot, check the Adding a New Robot page of the documentation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Afterwards, you should be able to see the robot in the viewer:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Robot spawn)","category":"page"},{"location":"tutorial/#Creating-a-Problem","page":"Tutorial","title":"Creating a Problem","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having loaded the robot, we are now ready to define the task we want to solve.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.jl uses a Direct Transcription[1] approach to optimize trajectories. This technique splits the trajectory into N equally-spaced[2] segments","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    t_I = t_1  t_2  dots  t_M = t_F","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where t_I and t_F are the start and final instants, respectively. This division results in M = N + 1 discrete mesh points (a.k.a. knots), for each of which TORA.jl discretizes the states of the system, as well as the control inputs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[1]: Betts, John T. Practical Methods for Optimal Control and Estimation Using Nonlinear Programming. SIAM, 2010.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[2]: Direct Transcription does not necessarily require equally-spaced segments.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To create a new problem, we use the TORA.Problem constructor, which takes three arguments:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"a TORA.Robot,\nthe number of knots we wish to use for representing the trajectory, and\nthe time step duration between each pair of consecutive knots.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose we want to optimize a motion with a total duration of 2 seconds, and that we want to calculate the control inputs to the system at a frequency of 150 Hz.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const duration = 2.0  # in seconds\nconst hz = 150\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In that case, the time step duration would be","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dt = 1/150","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the total number of knots would be given by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hz * duration + 1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Therefore, we create the problem by running","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"problem = TORA.Problem(robot, 301, 1/150)\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can use TORA.show_problem_info to print a summary of relevant information of a TORA.Problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.show_problem_info(problem)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The summary above shows that the total duration of the motion is 2.0 seconds, just like we wanted.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The summary also shows that there are no constraints defined yet, as we have just now created the problem.","category":"page"},{"location":"tutorial/#Defining-Constraints","page":"Tutorial","title":"Defining Constraints","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The decision variables of the optimization problem at every knot are:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"joint positions,\njoint velocities, and\njoint torques.[3]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[3]: An exception to this is the last knot, which only discretizes joint positions and joint velocities.","category":"page"},{"location":"tutorial/#Bounds-of-the-Decision-Variables","page":"Tutorial","title":"Bounds of the Decision Variables","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The bounds of the decision variables need not be defined. They are automatically inferred from the URDF model.","category":"page"},{"location":"tutorial/#Fixing-Values-of-the-Decision-Variables","page":"Tutorial","title":"Fixing Values of the Decision Variables","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is possible to fix the values of specific decision variables with:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.fix_joint_positions!\nTORA.fix_joint_velocities!\nTORA.fix_joint_torques!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose we want to enforce zero joint velocities both at the very start of the motion and at the very end of the motion. We can specify such constraints with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Constrain initial and final joint velocities to zero\nTORA.fix_joint_velocities!(problem, robot, 1, zeros(robot.n_v))\nTORA.fix_joint_velocities!(problem, robot, problem.num_knots, zeros(robot.n_v))\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's have a look at the problem summary output again:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.show_problem_info(problem)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The output confirms that there are now two knots for which we have fixed specific joint velocities.","category":"page"},{"location":"tutorial/#End-effector-Constraints","page":"Tutorial","title":"End-effector Constraints","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.constrain_ee_position! allows us to enforce specific positions for the end-effector of the robot.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we want the end-effector of the robot to be located at 05 02 03 in knot k = 33 we would write","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.constrain_ee_position!(problem, 33, [0.5, 0.2, 0.3])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But let's do something more interesting for this tutorial... Let's define a problem where the robot must trace a circular path. For that, we just need to call TORA.constrain_ee_position! multiple times with the right combination of knot and position such that we describe a circle.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"let CubicTimeScaling(Tf::Number, t::Number) = 3(t / Tf)^2 - 2(t / Tf)^3\n    for k = 1:2:problem.num_knots  # For every other knot\n        θ = CubicTimeScaling(problem.num_knots - 1, k - 1) * 2π\n        pos = [0.5, 0.2 * cos(θ), 0.8 + 0.2 * sin(θ)]\n        TORA.constrain_ee_position!(problem, k, pos)\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the snippet above, CubicTimeScaling is a helper function (a cubic polynomial). It allows us to specify a path for the end-effector that accelerates at first, and decelerates near the end. This is a better alternative to tracing the path with constant velocity.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The for loop inside the let block samples every other knot of the trajectory, and computes the position pos of the end-effector at that knot using the angle theta.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's print the problem summary once again:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.show_problem_info(problem)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The output correctly shows that we now have end-effector position constraints in 151 knots.","category":"page"},{"location":"tutorial/#Providing-an-Initial-Guess","page":"Tutorial","title":"Providing an Initial Guess","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Trajectory Optimization problems can be very challenging to solve. As such, providing a good initial guess (starting point) for the trajectory helps solvers significantly.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For our circle-tracing task, we are going to define a very simple (but reasonably good) initial guess: a static configuration, zero velocities, and zero torques.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, let's define the static configuration:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_q = [0, 0, 0, -π/2, 0, 0, 0]\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can visualize this configuration by running","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"zero!(robot.state)\nset_configuration!(robot.state, initial_q)\nset_configuration!(robot.mvis, configuration(robot.state))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will update the configuration of the robot in the viewer:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Robot initial configuration)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now define the initial guess for the joint positions with that fixed configuration, repeated for every knot:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_qs = repeat(initial_q, 1, problem.num_knots)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the joint velocities we are going to start with zeroes repeated for every knot:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_vs = zeros(robot.n_v, problem.num_knots)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And the same for the joint torques:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_τs = zeros(robot.n_τ, problem.num_knots)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can concatenate these matrices into a single one:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_guess = [initial_qs; initial_vs; initial_τs]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that the dimensions are 21×301, i.e., the dimension of each knot (mathbbR^21) times the 301 knots.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can flatten this matrix into a vector with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_guess = vec(initial_guess)\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Remember\nJulia follows a column-major convention. See Access arrays in memory order, along columns.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a very last step, we just need to truncate the last few values that correspond to the control inputs at the last knot. The last knot represents the end of the motion, so we only represent the robot state.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_guess = initial_guess[1:end - robot.n_τ]\nnothing  # hide","category":"page"},{"location":"tutorial/#Solving-the-Problem","page":"Tutorial","title":"Solving the Problem","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once we are happy with the problem definition, we just need to call solve and the optimization will start.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cpu_time, x, solver_log = TORA.solve_with_ipopt(problem, robot, initial_guess=initial_guess, user_options=Dict(\"print_level\" => 0))  # hide\ncpu_time, x, solver_log = TORA.solve_with_ipopt(problem, robot, initial_guess=initial_guess)\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nThere exist additional parameters that you can pass to TORA.solve_with_*. See Solver Interfaces.","category":"page"},{"location":"tutorial/#Showing-the-Results","page":"Tutorial","title":"Showing the Results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When the optimization finishes, we can playback the trajectory on the robot shown in the viewer.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.play_trajectory(vis, problem, robot, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You should be able to see this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<video src=\"../assets/videos/tutorial.mp4\" autoplay loop muted width=\"100%\" style=\"margin-bottom: 1em;\">Your browser does not support the video tag.</video>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also plot the positions, velocities, and torques of the obtained trajectory:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.plot_results(problem, robot, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Lastly, we can plot the TORA.SolverLog (returned by the solve function) to study the evolution of the feasibility error and of the objective function value (if one has been defined) per iteration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.plot_log(solver_log)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: You have reached the end\nThat concludes this tutorial. Congratulations! And thank you for sticking around this far.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<figure>\n    <img src=\"https://thumbs.gfycat.com/DesertedWhiteDotterel-size_restricted.gif\" alt=\"That's all Folks!\" width=\"50%\">\n</figure>","category":"page"}]
}
