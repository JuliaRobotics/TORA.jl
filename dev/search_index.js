var documenterSearchIndex = {"docs":
[{"location":"new_robot/#Adding-a-new-robot","page":"Adding a new robot","title":"Adding a new robot","text":"","category":"section"},{"location":"methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"methods/#Problem","page":"Methods","title":"Problem","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Problem","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"fix_joint_positions!\nfix_joint_velocities!\nfix_joint_torques!","category":"page"},{"location":"methods/#TORA.fix_joint_positions!","page":"Methods","title":"TORA.fix_joint_positions!","text":"fix_joint_positions!(problem, robot, knot, q)\n\nReturns a.\n\n\n\n\n\n","category":"function"},{"location":"methods/#TORA.fix_joint_velocities!","page":"Methods","title":"TORA.fix_joint_velocities!","text":"fix_joint_velocities!(problem, robot, knot, v)\n\nTo do.\n\n\n\n\n\n","category":"function"},{"location":"methods/#TORA.fix_joint_torques!","page":"Methods","title":"TORA.fix_joint_torques!","text":"fix_joint_torques!(problem, robot, knot, τ)\n\nTo do.\n\n\n\n\n\n","category":"function"},{"location":"methods/","page":"Methods","title":"Methods","text":"constrain_ee_position!","category":"page"},{"location":"methods/#TORA.constrain_ee_position!","page":"Methods","title":"TORA.constrain_ee_position!","text":"constrain_ee_position!(problem, knot, position)\n\nTo do.\n\n\n\n\n\n","category":"function"},{"location":"methods/","page":"Methods","title":"Methods","text":"show_problem_info","category":"page"},{"location":"methods/#Solver-Log","page":"Methods","title":"Solver Log","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"SolverLog\nupdate!\nlength\nsave\nload!","category":"page"},{"location":"methods/#TORA.SolverLog","page":"Methods","title":"TORA.SolverLog","text":"SolverLog(N::Int)\n\nCreates an empty NLP solver log.\n\nArguments\n\nN: the total number of decision variables of the NLP.\n\n\n\n\n\n","category":"type"},{"location":"methods/#TORA.update!","page":"Methods","title":"TORA.update!","text":"update!(log::SolverLog,\n        x::Array{Float64,2},\n        abs_feas_error::Array{Float64,1},\n        abs_opt_error::Array{Float64,1},\n        obj_value::Array{Float64,1},\n        fc_evals::Array{Float64,1},\n        ga_evals::Array{Float64,1})\n\nUpdates the log.\n\nArguments\n\nlog: instance of a SolverLog.\nx: an intermediate iterate point.\nabs_feas_error: absfeaserror at the current point.\nabs_opt_error: absopterror at the current point.\nobj_value: obj_value at the current point.\nfc_evals: the number of function evaluations requested by the NLP solver so far.\nga_evals: the number of gradient evaluations requested by the NLP solver so far.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Plot-Utilities","page":"Methods","title":"Plot Utilities","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"plot_results\nplot_log","category":"page"},{"location":"methods/#Index","page":"Methods","title":"Index","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"First things first: install Julia. You can follow my tutorial here.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To install TORA.jl, start Julia and enter Pkg mode by pressing ], and then run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"add https://github.com/ferrolho/TORA.jl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"After the command above, you are pretty much done.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: You are good to go\nI recommend you to go and follow the tutorial now.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The installation notes below need not be followed right now. At the end of the tutorial, I will refer you back here.","category":"page"},{"location":"install/#HSL-Routines-for-Ipopt","page":"Installation","title":"HSL Routines for Ipopt","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"This section will guide you through the steps required to install the Harwell Subroutine Library (HSL).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"info: Information about Ipopt and the HSL\nTORA.jl uses Ipopt (Interior-Point OPTimizer) by default, a large-scale nonlinear optimization solver.Ipopt itself depends on other solvers to handle systems of linear equations.The Harwell Subroutine Library (HSL) provides a number of linear solvers that can be used in Ipopt. ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"tip: Choose a good linear solver\nPicking a good linear solver is extremely important to maximise the performance of nonlinear solvers.For example, the linear solver MA27 is out dated and can be quite slow. MA57 is a much better alternative, especially for highly-sparse problems (such as trajectory optimization problems).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"First, install the following dependencies:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"sudo apt install gcc g++ gfortran git patch wget pkg-config liblapack-dev libmetis-dev","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Clone Ipopt to your Home folder:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone https://github.com/coin-or/Ipopt.git ~/Ipopt","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Clone the COIN-OR Tools project ThirdParty-HSL into Ipopt's folder:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cd ~/Ipopt\ngit clone https://github.com/coin-or-tools/ThirdParty-HSL.git","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Go to http://www.hsl.rl.ac.uk/ipopt/ and download Coin-HSL Full (Stable) [Linux x86_64].","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"warning: Warning\nDownloading Coin-HSL Full requires a licence. If you are an academic, you can get one for free.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Extract and rename the downloaded archive into ~/Ipopt/ThirdParty-HSL:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cd ~/Ipopt/ThirdParty-HSL\ntar -xvzf ~/Downloads/coinhsl-2019.05.21.tar.gz\nmv coinhsl-2019.05.21 coinhsl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Configure, make, and install HSL:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"./configure\nmake\nsudo make install","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"For compatibility, create libhsl.so linking to libcoinhsl.so:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cd /usr/local/lib\nsudo ln -s libcoinhsl.so libhsl.so","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Finally, add the following line to the end of your .bashrc (or .zshrc):","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"export LD_LIBRARY_PATH=\"/usr/local/lib:$LD_LIBRARY_PATH\"","category":"page"},{"location":"install/#Artelys-Knitro","page":"Installation","title":"Artelys Knitro","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"unknown: Not ready yet\nDocumentation to be written.","category":"page"},{"location":"#TORA.jl","page":"Home","title":"TORA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TORA.jl","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nA Jupyter notebook of this tutorial is available here.","category":"page"},{"location":"tutorial/#Setup","page":"Tutorial","title":"Setup","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We are going to use TORA.jl as well as other packages to visualise and handle rigid-body mechanisms.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TORA\nusing MeshCat\nusing RigidBodyDynamics","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using TORA\nusing MeshCat\nusing RigidBodyDynamics\n\nvis = Visualizer()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Try to call TORA.greet(). It should simply print \"Hello World!\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.greet()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we want to create a 3D viewer using MeshCat.jl","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"vis = Visualizer()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's open the visualizer (in a separate browser tab)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"open(vis)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It should look like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Empty viewer)","category":"page"},{"location":"tutorial/#Loading-a-Robot","page":"Tutorial","title":"Loading a Robot","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After starting the viewer, we are now ready to load a robot. Let's load a KUKA LBR iiwa 14 with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"robot = TORA.create_robot_kuka_iiwa_14(vis)\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nTo load a different robot, check the Adding a New Robot page of the documentation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Afterwards, you should be able to see the robot in the viewer:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Robot spawn)","category":"page"},{"location":"tutorial/#Creating-a-Problem","page":"Tutorial","title":"Creating a Problem","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having loaded the robot, we are now ready to define the task we want to solve.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.jl uses a Direct Transcription[1] approach to optimize trajectories. This technique splits the trajectory into N equally-spaced[2] segments","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    t_I = t_1  t_2  dots  t_M = t_F","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where t_I and t_F are the start and final instants, respectively. This division results in M = N + 1 discrete mesh points (a.k.a. knots), for each of which TORA.jl discretizes the states of the system, as well as the control inputs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[1]: Betts, John T. Practical Methods for Optimal Control and Estimation Using Nonlinear Programming. Society for Industrial and Applied Mathematics, 2010.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[2]: Direct Transcription does not necessarily require equally-spaced segments.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To create a new problem, we use the TORA.Problem constructor, which takes three arguments:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"a TORA.Robot,\nthe number of knots we wish to use for representing the trajectory, and\nthe time step duration between each pair of consecutive knots.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose we want to optimize a motion with a total duration of 2 seconds, and that we want to calculate the control inputs to the system at a frequency of 150 Hz.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const duration = 2.0  # in seconds\nconst hz = 150\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In that case, the time step duration would be","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"dt = 1/150","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the total number of knots would be given by","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hz * duration + 1","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Therefore, we create the problem by running","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"problem = TORA.Problem(robot, 301, 1/150)\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can use TORA.show_problem_info to print a summary of relevant information of a TORA.Problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.show_problem_info(problem)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The summary above shows that the total duration of the motion is 2.0 seconds, just like we wanted.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The summary also shows that there are no constraints defined yet, as we have just now created the problem.","category":"page"},{"location":"tutorial/#Defining-Constraints","page":"Tutorial","title":"Defining Constraints","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The decision variables of the optimization problem at every knot are:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"joint positions,\njoint velocities, and\njoint torques.[3]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[3]: An exception to this is the last knot, which only discretizes joint positions and joint velocities.","category":"page"},{"location":"tutorial/#Bounds-of-the-Decision-Variables","page":"Tutorial","title":"Bounds of the Decision Variables","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The bounds of the decision variables need not be defined. They are automatically inferred from the URDF model.","category":"page"},{"location":"tutorial/#Fixing-Values-of-the-Decision-Variables","page":"Tutorial","title":"Fixing Values of the Decision Variables","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is possible to fix the values of specific decision variables with:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.fix_joint_positions!\nTORA.fix_joint_velocities!\nTORA.fix_joint_torques!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose we want to enforce zero joint velocities both at the very start of the motion and at the very end of the motion. We can specify such constraints with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Constrain initial and final joint velocities to zero\nTORA.fix_joint_velocities!(problem, robot, 1, zeros(robot.n_v))\nTORA.fix_joint_velocities!(problem, robot, problem.num_knots, zeros(robot.n_v))\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's have a look at the problem summary output again:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.show_problem_info(problem)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The output confirms that there are now two knots for which we have fixed specific joint velocities.","category":"page"},{"location":"tutorial/#End-effector-Constraints","page":"Tutorial","title":"End-effector Constraints","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.constrain_ee_position! allows us to enforce specific positions for the end-effector of the robot.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If we want the end-effector of the robot to be located at 05 02 03 in knot k = 33 we would write","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.constrain_ee_position!(problem, 33, [0.5, 0.2, 0.3])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But let's do something more interesting for this tutorial... Let's define a problem where the robot must trace a circular path. For that, we just need to call TORA.constrain_ee_position! multiple times with the right combination of knot and position such that we describe a circle.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"let CubicTimeScaling(Tf::Number, t::Number) = 3(t / Tf)^2 - 2(t / Tf)^3\n    for k = 1:2:problem.num_knots  # For every other knot\n        θ = CubicTimeScaling(problem.num_knots - 1, k - 1) * 2π\n        pos = [0.5, 0.2 * cos(θ), 0.8 + 0.2 * sin(θ)]\n        TORA.constrain_ee_position!(problem, k, pos)\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the snippet above, CubicTimeScaling is a helper function (a cubic polynomial). It allows us to specify a path for the end-effector that accelerates at first, and decelerates near the end. This is a better alternative to tracing the path with constant velocity.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The for loop inside the let block samples every other knot of the trajectory, and computes the position pos of the end-effector at that knot using the angle theta.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's print the problem summary once again:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.show_problem_info(problem)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The output correctly shows that we now have end-effector position constraints in 151 knots.","category":"page"},{"location":"tutorial/#Providing-an-Initial-Guess","page":"Tutorial","title":"Providing an Initial Guess","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Trajectory Optimization problems can be very challenging to solve. As such, providing a good initial guess (starting point) for the trajectory helps solvers significantly.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For our circle-tracing task, we are going to define a very simple (but reasonably good) initial guess: a static configuration, zero velocities, and zero torques.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, let's define the static configuration:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_q = [0, 0, 0, -π/2, 0, 0, 0]\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can visualize this configuration by running","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"zero!(robot.state)\nset_configuration!(robot.state, initial_q)\nset_configuration!(robot.mvis, configuration(robot.state))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This will update the configuration of the robot in the viewer:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Robot initial configuration)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now define the initial guess for the joint positions with that fixed configuration, repeated for every knot:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_qs = repeat(initial_q, 1, problem.num_knots)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the joint velocities we are going to start with zeroes repeated for every knot:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_vs = zeros(robot.n_v, problem.num_knots)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And the same for the joint torques:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_τs = zeros(robot.n_τ, problem.num_knots)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can concatenate these matrices into a single one:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_guess = [initial_qs; initial_vs; initial_τs]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that the dimensions are 21×301, i.e., the dimension of each knot (mathbbR^21) times the 301 knots.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can flatten this matrix into a vector with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_guess = vec(initial_guess)\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Remember\nJulia follows a column-major convention. See Access arrays in memory order, along columns.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a very last step, we just need to truncate the last few values that correspond to the control inputs at the last knot. The last knot represents the end of the motion, so we only represent the robot state.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_guess = initial_guess[1:end - robot.n_τ]\nnothing  # hide","category":"page"},{"location":"tutorial/#Solving-the-Problem","page":"Tutorial","title":"Solving the Problem","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once we are happy with the problem definition, we just need to call solve and the optimization will start.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cpu_time, x, solver_log = TORA.solve_with_ipopt(problem, robot, initial_guess=initial_guess, user_options=Dict(\"print_level\" => 0))  # hide\ncpu_time, x, solver_log = TORA.solve_with_ipopt(problem, robot, initial_guess=initial_guess)\nnothing  # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"info: Info\nThere exist additional parameters that you can pass to TORA.solve_with_*. See Advanced Usage.","category":"page"},{"location":"tutorial/#Showing-the-Results","page":"Tutorial","title":"Showing the Results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When the optimization finishes, we can playback the trajectory on the robot shown in the viewer.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.play_trajectory(vis, problem, robot, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You should be able to see this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<video src=\"../assets/videos/tutorial.mp4\" autoplay loop muted width=\"100%\" style=\"margin-bottom: 1em;\">Your browser does not support the video tag.</video>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also plot the positions, velocities, and torques of the obtained trajectory:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.plot_results(problem, robot, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Lastly, we can plot the TORA.SolverLog (returned by the solve function) to study the evolution of the feasibility error and of the objective function value (if one has been defined) per iteration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"TORA.plot_log(solver_log)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: You have reached the end\nThat concludes this tutorial. Congratulations! And thank you for sticking around this far.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"<figure>\n    <img src=\"https://thumbs.gfycat.com/DesertedWhiteDotterel-size_restricted.gif\" alt=\"That's all Folks!\" width=\"50%\">\n</figure>","category":"page"}]
}
