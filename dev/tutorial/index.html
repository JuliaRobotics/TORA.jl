<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · TORA.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="TORA.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="TORA.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">TORA.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Loading-a-Robot"><span>Loading a Robot</span></a></li><li><a class="tocitem" href="#Creating-a-Problem"><span>Creating a Problem</span></a></li><li><a class="tocitem" href="#Defining-Constraints"><span>Defining Constraints</span></a></li><li><a class="tocitem" href="#Providing-an-Initial-Guess"><span>Providing an Initial Guess</span></a></li><li><a class="tocitem" href="#Solving-the-Problem"><span>Solving the Problem</span></a></li><li><a class="tocitem" href="#Showing-the-Results"><span>Showing the Results</span></a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../robot/">Robot</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../solver_interfaces/">Solver Interfaces</a></li><li><a class="tocitem" href="../solver_log/">Solver Log</a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../new_robot/">Adding a New Robot</a></li><li><a class="tocitem" href="../how_it_works/">How TORA.jl Works</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/TORA.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial assumes you have already installed Julia and TORA.jl. See <a href="../install/#Installation">Installation</a>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>A <a href="https://jupyter.org/">Jupyter</a> notebook of this tutorial is available <a href="https://github.com/JuliaRobotics/TORA.jl/blob/main/notebooks/Tutorial.ipynb">here</a>.</p></div></div><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><p>We are going to use TORA.jl as well as other packages to visualize and handle rigid-body mechanisms.</p><pre><code class="language-julia hljs">using TORA
using MeshCat
using RigidBodyDynamics</code></pre><p>Try to call <code>TORA.greet()</code>. It should simply print &quot;Hello World!&quot;</p><pre><code class="language-julia hljs">TORA.greet()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Hello World!</code></pre><p>Next, we want to create a 3D viewer using <a href="https://github.com/rdeits/MeshCat.jl">MeshCat.jl</a></p><pre><code class="language-julia hljs">vis = Visualizer()</code></pre><p>Let&#39;s open the visualizer (in a separate browser tab)</p><pre><code class="language-julia hljs">open(vis)</code></pre><p>It should look like this:</p><p><img src="../assets/screenshots/tutorial_01.png" alt="Empty viewer"/></p><h2 id="Loading-a-Robot"><a class="docs-heading-anchor" href="#Loading-a-Robot">Loading a Robot</a><a id="Loading-a-Robot-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-a-Robot" title="Permalink"></a></h2><p>After starting the viewer, we are now ready to load a robot. Let&#39;s load a <a href="https://www.kuka.com/en-gb/products/robotics-systems/industrial-robots/lbr-iiwa">KUKA LBR iiwa 14</a> with</p><pre><code class="language- hljs">robot = TORA.create_robot_kuka_iiwa_14(vis)
nothing  # hide</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To load a different robot, check the <a href="../new_robot/#Adding-a-New-Robot">Adding a New Robot</a> page of the documentation.</p></div></div><p>Afterwards, you should be able to see the robot in the viewer:</p><p><img src="../assets/screenshots/tutorial_02.png" alt="Robot spawn"/></p><h2 id="Creating-a-Problem"><a class="docs-heading-anchor" href="#Creating-a-Problem">Creating a Problem</a><a id="Creating-a-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Problem" title="Permalink"></a></h2><p>Having loaded the robot, we are now ready to define the task we want to solve.</p><p>TORA.jl uses a Direct Transcription<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> approach to optimize trajectories. This technique splits the trajectory into <span>$N$</span> equally-spaced<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> segments</p><p class="math-container">\[    t_I = t_1 &lt; t_2 &lt; \dots &lt; t_M = t_F,\]</p><p>where <span>$t_I$</span> and <span>$t_F$</span> are the start and final instants, respectively. This division results in <span>$M = N + 1$</span> discrete <em>mesh points</em> (a.k.a. <em>knots</em>), for each of which TORA.jl discretizes the states of the system, as well as the control inputs.</p><p>To create a new problem, we use the <a href="../problem/#TORA.Problem"><code>TORA.Problem</code></a> constructor, which takes three arguments:</p><ol><li>a <a href="../robot/#TORA.Robot"><code>TORA.Robot</code></a>,</li><li>the number of <em>knots</em> we wish to use for representing the trajectory, and</li><li>the time step duration between each pair of consecutive knots.</li></ol><p>Suppose we want to optimize a motion with a total duration of <em>2 seconds</em>, and that we want to calculate the control inputs to the system at a frequency of <em>150 Hz</em>.</p><pre><code class="language-julia hljs">const duration = 2.0  # in seconds
const hz = 150</code></pre><p>In that case, the time step duration would be</p><pre><code class="language-julia hljs">dt = 1/150</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.006666666666666667</code></pre><p>and the total number of <em>knots</em> would be given by</p><pre><code class="language-julia hljs">hz * duration + 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">301.0</code></pre><p>Therefore, we create the problem by running</p><pre><code class="language- hljs">problem = TORA.Problem(robot, 301, 1/150)
nothing  # hide</code></pre><p>We can use <a href="../problem/#TORA.show_problem_info-Tuple{Problem}"><code>TORA.show_problem_info</code></a> to print a summary of relevant information of a <a href="../problem/#TORA.Problem"><code>TORA.Problem</code></a>.</p><pre><code class="language- hljs">TORA.show_problem_info(problem)</code></pre><p>The summary above shows that the total duration of the motion is 2.0 seconds, just like we wanted.</p><p>The summary also shows that there are no constraints defined yet, as we have just now created the problem.</p><h2 id="Defining-Constraints"><a class="docs-heading-anchor" href="#Defining-Constraints">Defining Constraints</a><a id="Defining-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Constraints" title="Permalink"></a></h2><p>The decision variables of the optimization problem at every <em>knot</em> are:</p><ul><li>joint positions,</li><li>joint velocities, and</li><li>joint torques.<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup></li></ul><h3 id="Bounds-of-the-Decision-Variables"><a class="docs-heading-anchor" href="#Bounds-of-the-Decision-Variables">Bounds of the Decision Variables</a><a id="Bounds-of-the-Decision-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Bounds-of-the-Decision-Variables" title="Permalink"></a></h3><p>The bounds of the decision variables need not be defined. They are automatically inferred from the URDF model.</p><h3 id="Fixing-Values-of-the-Decision-Variables"><a class="docs-heading-anchor" href="#Fixing-Values-of-the-Decision-Variables">Fixing Values of the Decision Variables</a><a id="Fixing-Values-of-the-Decision-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-Values-of-the-Decision-Variables" title="Permalink"></a></h3><p>It is possible to fix the values of specific decision variables with:</p><ul><li><a href="../problem/#TORA.fix_joint_positions!-Tuple{Problem, Robot, Any, Any}"><code>TORA.fix_joint_positions!</code></a></li><li><a href="../problem/#TORA.fix_joint_velocities!-Tuple{Problem, Robot, Any, Any}"><code>TORA.fix_joint_velocities!</code></a></li><li><a href="../problem/#TORA.fix_joint_torques!-Tuple{Problem, Robot, Any, Any}"><code>TORA.fix_joint_torques!</code></a></li></ul><p>Suppose we want to enforce zero joint velocities both at the very <em>start</em> of the motion and at the very <em>end</em> of the motion. We can specify such constraints with</p><pre><code class="language- hljs"># Constrain initial and final joint velocities to zero
TORA.fix_joint_velocities!(problem, robot, 1, zeros(robot.n_v))
TORA.fix_joint_velocities!(problem, robot, problem.num_knots, zeros(robot.n_v))
nothing  # hide</code></pre><p>Let&#39;s have a look at the problem summary output again:</p><pre><code class="language- hljs">TORA.show_problem_info(problem)</code></pre><p>The output confirms that there are now <em>two knots</em> for which we have fixed specific joint velocities.</p><h3 id="End-effector-Constraints"><a class="docs-heading-anchor" href="#End-effector-Constraints">End-effector Constraints</a><a id="End-effector-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#End-effector-Constraints" title="Permalink"></a></h3><p><a href="../problem/#TORA.constrain_ee_position!-Tuple{Problem, Any, Any}"><code>TORA.constrain_ee_position!</code></a> allows us to enforce specific positions for the end-effector of the robot.</p><p>If we want the end-effector of the robot to be located at <span>$[0.5, 0.2, 0.3]$</span> in knot <span>$k = 33$</span> we would write</p><pre><code class="language-julia hljs">TORA.constrain_ee_position!(problem, 33, [0.5, 0.2, 0.3])</code></pre><p>But let&#39;s do something more interesting for this tutorial... Let&#39;s define a problem where the robot must trace a circular path. For that, we just need to call <a href="../problem/#TORA.constrain_ee_position!-Tuple{Problem, Any, Any}"><code>TORA.constrain_ee_position!</code></a> multiple times with the right combination of knot and position such that we describe a circle.</p><pre><code class="language- hljs">let CubicTimeScaling(Tf::Number, t::Number) = 3(t / Tf)^2 - 2(t / Tf)^3
    for k = 1:2:problem.num_knots  # For every other knot
        θ = CubicTimeScaling(problem.num_knots - 1, k - 1) * 2π
        pos = [0.5, 0.2 * cos(θ), 0.8 + 0.2 * sin(θ)]
        TORA.constrain_ee_position!(problem, k, pos)
    end
end</code></pre><p>In the snippet above, <code>CubicTimeScaling</code> is a helper function (a cubic polynomial). It allows us to specify a path for the end-effector that accelerates at first, and decelerates near the end. This is a better alternative to tracing the path with constant velocity.</p><p>The <code>for</code> loop inside the <code>let</code> block samples every other knot of the trajectory, and computes the position <code>pos</code> of the end-effector at that knot using the angle <span>$\theta$</span>.</p><p>Let&#39;s print the problem summary once again:</p><pre><code class="language- hljs">TORA.show_problem_info(problem)</code></pre><p>The output correctly shows that we now have end-effector position constraints in 151 knots.</p><h2 id="Providing-an-Initial-Guess"><a class="docs-heading-anchor" href="#Providing-an-Initial-Guess">Providing an Initial Guess</a><a id="Providing-an-Initial-Guess-1"></a><a class="docs-heading-anchor-permalink" href="#Providing-an-Initial-Guess" title="Permalink"></a></h2><p>Trajectory Optimization problems can be very challenging to solve. As such, providing a good initial guess (starting point) for the trajectory helps solvers significantly.</p><p>For our circle-tracing task, we are going to define a very simple (but reasonably good) initial guess: a static configuration, zero velocities, and zero torques.</p><p>First, let&#39;s define the static configuration:</p><pre><code class="language-julia hljs">initial_q = [0, 0, 0, -π/2, 0, 0, 0]</code></pre><p>We can visualize this configuration by running</p><pre><code class="language- hljs">zero!(robot.state)
set_configuration!(robot.state, initial_q)
set_configuration!(robot.mvis, configuration(robot.state))</code></pre><p>This will update the configuration of the robot in the viewer:</p><p><img src="../assets/screenshots/tutorial_03.png" alt="Robot initial configuration"/></p><p>We can now define the initial guess for the joint positions with that fixed configuration, repeated for every knot:</p><pre><code class="language- hljs">initial_qs = repeat(initial_q, 1, problem.num_knots)</code></pre><p>For the joint velocities we are going to start with zeroes repeated for every knot:</p><pre><code class="language- hljs">initial_vs = zeros(robot.n_v, problem.num_knots)</code></pre><p>And the same for the joint torques:</p><pre><code class="language- hljs">initial_τs = zeros(robot.n_τ, problem.num_knots)</code></pre><p>We can concatenate these matrices into a single one:</p><pre><code class="language- hljs">initial_guess = [initial_qs; initial_vs; initial_τs]</code></pre><p>Notice that the dimensions are <code>21×301</code>, i.e., the dimension of each knot (<span>$\mathbb{R}^{21}$</span>) times the 301 knots.</p><p>We can flatten this matrix into a vector with</p><pre><code class="language- hljs">initial_guess = vec(initial_guess)
nothing  # hide</code></pre><div class="admonition is-info"><header class="admonition-header">Remember</header><div class="admonition-body"><p>Julia follows a column-major convention. See <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-column-major">Access arrays in memory order, along columns</a>.</p></div></div><p>As a very last step, we just need to truncate the last few values that correspond to the control inputs at the last knot. The last knot represents the end of the motion, so we only represent the robot state.</p><pre><code class="language- hljs">initial_guess = initial_guess[1:end - robot.n_τ]
nothing  # hide</code></pre><h2 id="Solving-the-Problem"><a class="docs-heading-anchor" href="#Solving-the-Problem">Solving the Problem</a><a id="Solving-the-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-Problem" title="Permalink"></a></h2><p>Once we are happy with the problem definition, we just need to call solve and the optimization will start.</p><pre><code class="language- hljs">cpu_time, x, solver_log = TORA.solve_with_ipopt(problem, robot, initial_guess=initial_guess, user_options=Dict(&quot;print_level&quot; =&gt; 0))  # hide
cpu_time, x, solver_log = TORA.solve_with_ipopt(problem, robot, initial_guess=initial_guess)
nothing  # hide</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>There exist additional parameters that you can pass to <code>TORA.solve_with_*</code>. See <a href="../solver_interfaces/#Solver-Interfaces">Solver Interfaces</a>.</p></div></div><h2 id="Showing-the-Results"><a class="docs-heading-anchor" href="#Showing-the-Results">Showing the Results</a><a id="Showing-the-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Showing-the-Results" title="Permalink"></a></h2><p>When the optimization finishes, we can playback the trajectory on the robot shown in the viewer.</p><pre><code class="language-julia hljs">TORA.play_trajectory(vis, problem, robot, x)</code></pre><p>You should be able to see this:</p><video src="../assets/videos/tutorial.mp4" autoplay loop muted width="100%" style="margin-bottom: 1em;">Your browser does not support the video tag.</video><p>We can also plot the positions, velocities, and torques of the obtained trajectory:</p><pre><code class="language- hljs">TORA.plot_results(problem, robot, x)</code></pre><p>Lastly, we can plot the <a href="../solver_log/#TORA.SolverLog"><code>TORA.SolverLog</code></a> (returned by the solve function) to study the evolution of the feasibility error and of the objective function value (if one has been defined) per iteration.</p><pre><code class="language- hljs">TORA.plot_log(solver_log)</code></pre><div class="admonition is-success"><header class="admonition-header">You have reached the end</header><div class="admonition-body"><p>That concludes this tutorial. Congratulations! And thank you for sticking around this far.</p></div></div><figure>
    <img src="https://thumbs.gfycat.com/DesertedWhiteDotterel-size_restricted.gif" alt="That's all Folks!" width="50%">
</figure><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Betts, John T. <a href="https://epubs.siam.org/doi/book/10.1137/1.9780898718577"><em>Practical Methods for Optimal Control and Estimation Using Nonlinear Programming</em></a>. SIAM, 2010.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Direct Transcription does not necessarily require equally-spaced segments.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>An exception to this is the last knot, which only discretizes joint positions and joint velocities.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../install/">« Installation</a><a class="docs-footer-nextpage" href="../robot/">Robot »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.20 on <span class="colophon-date" title="Tuesday 12 July 2022 16:59">Tuesday 12 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
